<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Xadrez com Xeque, Roque e Promoção</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #f0f0f0;
      padding: 20px;
    }
    #controls {
      margin: 10px 0;
    }
    button {
      margin: 0 5px;
      padding: 8px 12px;
      font-size: 1em;
    }
    #status {
      margin: 10px 0;
      font-size: 1.2em;
      font-weight: bold;
      min-height: 1.5em;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      border: 2px solid #333;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }
    .square {
      width: 60px;
      height: 60px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 40px;
      cursor: pointer;
      user-select: none;
      position: relative;
    }
    .light { background: #f0d9b5; }
    .dark  { background: #b58863; }
    .selected { background: #aec6cf !important; }
    .valid-move::after {
      content: "";
      position: absolute;
      width: 20px;
      height: 20px;
      background: rgba(0, 128, 0, 0.5);
      border-radius: 50%;
    }
    .in-check {
      box-shadow: inset 0 0 10px 3px red;
    }
  </style>
</head>
<body>

  <h1>♟️ Xadrez Avançado ♟️</h1>
  <div id="status">Turno: Brancas</div>
  <div id="controls">
    <button onclick="novaPartida()">Nova Partida</button>
    <button onclick="salvarPartida()">Salvar</button>
    <button onclick="carregarPartida()">Carregar</button>
  </div>
  <div id="board"></div>

  <script>
    const PIECES = {
      'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
      'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
    };

    // Estado do jogo
    let board = [];
    let turno = 'w';
    let selecionada = null;
    let reiEmXeque = false;
    let gameOver = false;

    // Controle de roque
    let roque = {
      w: { short: true, long: true },
      b: { short: true, long: true }
    };

    // Posições originais das torres (para roque)
    const torresPos = {
      w: { short: [7,7], long: [7,0] },
      b: { short: [0,7], long: [0,0] }
    };

    const statusEl = document.getElementById('status');
    const boardEl = document.getElementById('board');

    // Inicializa tabuleiro
    function novaPartida() {
      board = [
        ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
        ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
        ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
      ];
      turno = 'w';
      selecionada = null;
      reiEmXeque = false;
      gameOver = false;
      roque = {
        w: { short: true, long: true },
        b: { short: true, long: true }
      };
      render();
    }

    function isWhite(piece) {
      return piece && piece === piece.toUpperCase();
    }

    function getReiPos(cor) {
      const white = cor === 'w';
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = board[r][c];
          if (p && ((white && p === 'K') || (!white && p === 'k'))) {
            return { row: r, col: c };
          }
        }
      }
      return null;
    }

    function emXeque(cor) {
      const rei = getReiPos(cor);
      if (!rei) return false;

      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = board[r][c];
          if (p && isWhite(p) !== (cor === 'w')) {
            const moves = getValidMovesRaw(r, c, true); // sem considerar xeque
            if (moves.some(m => m.row === rei.row && m.col === rei.col)) {
              return true;
            }
          }
        }
      }
      return false;
    }

    // Movimentos sem verificar xeque (usado internamente)
    function getValidMovesRaw(row, col, ignoreCheck = false) {
      const piece = board[row][col];
      if (!piece) return [];
      const white = isWhite(piece);
      const type = white ? piece.toLowerCase() : piece;
      const moves = [];

      const addMove = (r, c) => {
        if (r < 0 || r > 7 || c < 0 || c > 7) return false;
        const target = board[r][c];
        if (target === null || isWhite(target) !== white) {
          moves.push({ row: r, col: c });
          return target === null; // continua se vazio
        }
        return false; // peça amiga ou inimiga → para
      };

      switch (type) {
        case 'p':
          const dir = white ? -1 : 1;
          if (board[row + dir]?.[col] === null) {
            addMove(row + dir, col);
            if ((white && row === 6) || (!white && row === 1)) {
              if (board[row + 2 * dir]?.[col] === null) addMove(row + 2 * dir, col);
            }
          }
          if (col > 0 && board[row + dir]?.[col - 1] !== null && isWhite(board[row + dir][col - 1]) !== white)
            moves.push({ row: row + dir, col: col - 1 });
          if (col < 7 && board[row + dir]?.[col + 1] !== null && isWhite(board[row + dir][col + 1]) !== white)
            moves.push({ row: row + dir, col: col + 1 });
          break;

        case 'r':
          for (let d of [[0,1],[0,-1],[1,0],[-1,0]]) {
            for (let i = 1; i <= 7; i++) {
              if (!addMove(row + d[0]*i, col + d[1]*i)) break;
            }
          }
          break;

        case 'b':
          for (let d of [[1,1],[1,-1],[-1,1],[-1,-1]]) {
            for (let i = 1; i <= 7; i++) {
              if (!addMove(row + d[0]*i, col + d[1]*i)) break;
            }
          }
          break;

        case 'q':
          for (let d of [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]) {
            for (let i = 1; i <= 7; i++) {
              if (!addMove(row + d[0]*i, col + d[1]*i)) break;
            }
          }
          break;

        case 'k':
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              addMove(row + dr, col + dc);
            }
          }
          // Roque
          if (!ignoreCheck && !emXeque(turno)) {
            if (white && roque.w.short && 
                board[7][5] === null && board[7][6] === null &&
                !emXequeSimulado(7, 4, 7, 5)) {
              moves.push({ row: 7, col: 6, special: 'roque-short' });
            }
            if (white && roque.w.long && 
                board[7][1] === null && board[7][2] === null && board[7][3] === null &&
                !emXequeSimulado(7, 4, 7, 3)) {
              moves.push({ row: 7, col: 2, special: 'roque-long' });
            }
            if (!white && roque.b.short && 
                board[0][5] === null && board[0][6] === null &&
                !emXequeSimulado(0, 4, 0, 5)) {
              moves.push({ row: 0, col: 6, special: 'roque-short' });
            }
            if (!white && roque.b.long && 
                board[0][1] === null && board[0][2] === null && board[0][3] === null &&
                !emXequeSimulado(0, 4, 0, 3)) {
              moves.push({ row: 0, col: 2, special: 'roque-long' });
            }
          }
          break;

        case 'n':
          const offsets = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
          offsets.forEach(([dr,dc]) => addMove(row+dr, col+dc));
          break;
      }

      return moves;
    }

    function emXequeSimulado(fromRow, fromCol, toRow, toCol) {
      const temp = board[toRow][toCol];
      board[toRow][toCol] = board[fromRow][fromCol];
      board[fromRow][fromCol] = null;
      const emXequeAgora = emXeque(turno);
      board[fromRow][fromCol] = board[toRow][toCol];
      board[toRow][toCol] = temp;
      return emXequeAgora;
    }

    function getValidMoves(row, col) {
      const raw = getValidMovesRaw(row, col);
      const result = [];
      for (const move of raw) {
        if (!emXequeSimulado(row, col, move.row, move.col)) {
          result.push(move);
        }
      }
      return result;
    }

    function temMovimentosValidos(cor) {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = board[r][c];
          if (p && isWhite(p) === (cor === 'w')) {
            const moves = getValidMoves(r, c);
            if (moves.length > 0) return true;
          }
        }
      }
      return false;
    }

    function handleSquareClick(row, col) {
      if (gameOver) return;

      const piece = board[row][col];

      if (selecionada) {
        const validMoves = getValidMoves(selecionada.row, selecionada.col);
        const move = validMoves.find(m => m.row === row && m.col === col);

        if (move) {
          // Executa movimento
          const origem = board[selecionada.row][selecionada.col];
          const alvo = board[row][col];

          // Atualiza estado de roque
          if (origem === 'K') { roque.w.short = roque.w.long = false; }
          if (origem === 'k') { roque.b.short = roque.b.long = false; }
          if (origem === 'R' && selecionada.row === 7 && selecionada.col === 0) roque.w.long = false;
          if (origem === 'R' && selecionada.row === 7 && selecionada.col === 7) roque.w.short = false;
          if (origem === 'r' && selecionada.row === 0 && selecionada.col === 0) roque.b.long = false;
          if (origem === 'r' && selecionada.row === 0 && selecionada.col === 7) roque.b.short = false;

          // Roque
          if (move.special === 'roque-short') {
            board[row][col - 1] = board[row][7];
            board[row][7] = null;
            board[row][col] = origem;
            board[selecionada.row][selecionada.col] = null;
          } else if (move.special === 'roque-long') {
            board[row][col + 1] = board[row][0];
            board[row][0] = null;
            board[row][col] = origem;
            board[selecionada.row][selecionada.col] = null;
          } else {
            board[row][col] = origem;
            board[selecionada.row][selecionada.col] = null;

            // Promoção de peão
            if ((origem === 'P' && row === 0) || (origem === 'p' && row === 7)) {
              const promocao = prompt("Promover peão para? (Q, R, B, N)", "Q");
              const escolha = (promocao || "Q").toUpperCase().charAt(0);
              if (['Q','R','B','N'].includes(escolha)) {
                board[row][col] = origem === 'P' ? escolha : escolha.toLowerCase();
              } else {
                board[row][col] = origem === 'P' ? 'Q' : 'q';
              }
            }
          }

          // Troca turno
          turno = turno === 'w' ? 'b' : 'w';
          selecionada = null;

          // Verifica xeque e xeque-mate
          reiEmXeque = emXeque(turno);
          if (reiEmXeque) {
            if (!temMovimentosValidos(turno)) {
              statusEl.textContent = `XEQUE-MATE! ${turno === 'b' ? 'Brancas' : 'Pretas'} vencem!`;
              gameOver = true;
            } else {
              statusEl.textContent = `XEQUE! Turno: ${turno === 'w' ? 'Brancas' : 'Pretas'}`;
            }
          } else {
            if (!temMovimentosValidos(turno)) {
              statusEl.textContent = "EMPATE por afogamento!";
              gameOver = true;
            } else {
              statusEl.textContent = `Turno: ${turno === 'w' ? 'Brancas' : 'Pretas'}`;
            }
          }

          render();
          return;
        }

        // Clicou em outra peça sua?
        if (piece && ((turno === 'w' && isWhite(piece)) || (turno === 'b' && !isWhite(piece)))) {
          selecionada = { row, col };
          render();
          return;
        }

        selecionada = null;
        render();
        return;
      }

      if (piece && ((turno === 'w' && isWhite(piece)) || (turno === 'b' && !isWhite(piece)))) {
        selecionada = { row, col };
        render();
      }
    }

    function render() {
      boardEl.innerHTML = '';
      const reiPos = getReiPos(turno);

      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const square = document.createElement('div');
          square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
          square.dataset.row = row;
          square.dataset.col = col;

          const piece = board[row][col];
          if (piece) square.textContent = PIECES[piece];

          if (selecionada && selecionada.row === row && selecionada.col === col) {
            square.classList.add('selected');
          }

          if (reiEmXeque && reiPos && reiPos.row === row && reiPos.col === col) {
            square.classList.add('in-check');
          }

          square.addEventListener('click', () => handleSquareClick(row, col));
          boardEl.appendChild(square);
        }
      }
    }

    // === SALVAR / CARREGAR ===
    function salvarPartida() {
      const partida = {
        board,
        turno,
        roque,
        timestamp: new Date().toISOString()
      };
      localStorage.setItem('xadrez_partida', JSON.stringify(partida));
      alert('Partida salva!');
    }

    function carregarPartida() {
      const data = localStorage.getItem('xadrez_partida');
      if (data) {
        const partida = JSON.parse(data);
        board = partida.board;
        turno = partida.turno;
        roque = partida.roque;
        selecionada = null;
        reiEmXeque = emXeque(turno);
        gameOver = false;
        render();
        statusEl.textContent = `Carregado! Turno: ${turno === 'w' ? 'Brancas' : 'Pretas'}`;
      } else {
        alert('Nenhuma partida salva encontrada.');
      }
    }

    // Inicia
    novaPartida();
  </script>
</body>
</html>